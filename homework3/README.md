## Домашнее задание 3-4

### Задача

Нужно реализовать простое HTTP API сервиса скоринга. Шаблон уже есть в api.py, тесты в test.py.
API необычно тем, что пользователь дергают методы POST запросами. Чтобы получить результат
пользователь отправляет в POST запросе валидный JSON определенного формата на локейшн /method.

**Структура json-запроса**

```
{
  "account": "<имя компании партнера>",
  "login": "<имя пользователя>",
  "method": "<имя метода>",
  "token": "<аутентификационный токен>",
  "arguments": {}
}
```

* account - строка, опционально, может быть пустым
* login - строка, обязательно, может быть пустым
* method - строка, обязательно, может быть пустым
* token - строка, обязательно, может быть пустым
* arguments - словарь (объект в терминах json), обязательно, может быть пустым

> **Валидация**: запрос валиден, если валидны все поля по отдельности

**Структура ответа:**

```
{
  "code": <числовой код>,
  "response": {<ответ вызываемого метода>}
}
```
```
{
    "code": <числовой код>,
    "error": {<сообщение об ошибке>}
}
```

### Метод online_score.

**Аргументы:**

* phone - строка или число, длиной 11, начинается с 7, опционально, может быть пустым
* email - строка, в которой есть @, опционально, может быть пустым
* first_name - строка, опционально, может быть пустым
* last_name - строка, опционально, может быть пустым
* birthday - дата в формате DD.MM.YYYY, с которой прошло не больше 70 лет, опционально, может быть пустым
* gender - число 0, 1 или 2, опционально, может быть пустым

> **Валидация**: аргументы валидны, если валидны все поля по отдельности и если присутсвует хоть одна пара
> *phone-email, first name-last name, gender-birthday с непустыми значениями*.

**Контекст:** в словарь контекста должна прописываться запись  "has" - список полей,
которые были не пустые для данного запроса.

**Структура ответа:**

в ответ выдается произвольное число, которое больше или равно 0

```{"score": <число>}```

или если запрос пришел от валидного пользователя admin

```{"score": 42}```

или если произошла ошибка валидации

```{"code": 422, "error": "<сообщение о том какое поле невалидно>"}```

```$ curl -X POST  -H "Content-Type: application/json" -d '{"account": "horns&hoofs", "login": "h&f", "method": "online_score", "token": "55cc9ce545bcd144300fe9efc28e65d415b923ebb6be1e19d2750a2c03e80dd209a27954dca045e5bb12418e7d89b6d718a9e35af34e14e1d5bcd5a08f21fc95", "arguments": {"phone": "79175002040", "email": "stupnikov@otus.ru", "first_name": "Стансилав", "last_name": "Ступников", "birthday": "01.01.1990", "gender": 1}}' http://127.0.0.1:8080/method/```
```-> {"code": 200, "response": {"score": 5.0}}```

### Метод clients_interests.

**Аргументы:**

* client_ids - массив числе, обязательно, не пустое
* date - дата в формате DD.MM.YYYY, опционально, может быть пустым

> **Валидация**: аргументы валидны, если валидны все поля по отдельности.

**Контекст:** в словарь контекста должна прописываться запись  "nclients" - количество id'шников,
переденанных в запрос.

**Структура ответа:**

в ответ выдается словарь <id клиента>:<список интересов>. Список генерировать произвольно.

```{"client_id1": ["interest1", "interest2" ...], "client2": [...] ...}```

или если произошла ошибка валидации

```{"code": 422, "error": "<сообщение о том какое поле невалидно>"}```

```$ curl -X POST  -H "Content-Type: application/json" -d '{"account": "horns&hoofs", "login": "admin", "method": "clients_interests", "token": "d3573aff1555cd67dccf21b95fe8c4dc8732f33fd4e32461b7fe6a71d83c947688515e36774c00fb630b039fe2223c991f045f13f24091386050205c324687a0", "arguments": {"client_ids": [1,2,3,4], "date": "15.12.2017"}}' http://127.0.0.1:8080/method/```
```-> {"code": 403, "response": "Forbidden"}```


**Использвание хранилища Redis**

Redis поднят в докере

```docker pull redis```

```docker run -d --name redis -p 6379:6379 redis```

Написан класс-обертка с методами cache_get, cache_set для организации передподключений в случае ошибок
(параметры timeout, max_count_attempt передаются во время создания экземпляра класса)

При тестировании можно использовать либо класс api.MyRedis(), либо класс MockMyRedis.

При использовании Mock-класса или при функционирующем редисе все тесты проходят,
при использовании MyRedis() в случае ошибок подключения test_ok_interests_request падает с ошибкой
(get_interests при вызове store.get генерирует исключение)

**Тестирование**

1. test_empty_request

2. test_bad_auth

3. test_invalid_method_request

4. test_invalid_score_request

5. test_ok_score_request

6. test_ok_score_admin_request

7. test_invalid_interests_request

8. test_ok_interests_request
